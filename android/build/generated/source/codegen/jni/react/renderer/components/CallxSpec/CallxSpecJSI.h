/**
 * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
 *
 * Do not edit this file as changes may cause incorrect behavior and will be lost
 * once the code is regenerated.
 *
 * @generated by codegen project: GenerateModuleH.js
 */

#pragma once

#include <ReactCommon/TurboModule.h>
#include <react/bridging/Bridging.h>

namespace facebook::react {


  
#pragma mark - NativeCallxCallData

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7>
struct NativeCallxCallData {
  P0 callId;
  P1 callerName;
  P2 callerPhone;
  P3 callerAvatar;
  P4 hasVideo;
  P5 endReason;
  P6 timestamp;
  P7 originalPayload;
  bool operator==(const NativeCallxCallData &other) const {
    return callId == other.callId && callerName == other.callerName && callerPhone == other.callerPhone && callerAvatar == other.callerAvatar && hasVideo == other.hasVideo && endReason == other.endReason && timestamp == other.timestamp && originalPayload == other.originalPayload;
  }
};

template <typename T>
struct NativeCallxCallDataBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.callId)>(rt, value.getProperty(rt, "callId"), jsInvoker),
      bridging::fromJs<decltype(types.callerName)>(rt, value.getProperty(rt, "callerName"), jsInvoker),
      bridging::fromJs<decltype(types.callerPhone)>(rt, value.getProperty(rt, "callerPhone"), jsInvoker),
      bridging::fromJs<decltype(types.callerAvatar)>(rt, value.getProperty(rt, "callerAvatar"), jsInvoker),
      bridging::fromJs<decltype(types.hasVideo)>(rt, value.getProperty(rt, "hasVideo"), jsInvoker),
      bridging::fromJs<decltype(types.endReason)>(rt, value.getProperty(rt, "endReason"), jsInvoker),
      bridging::fromJs<decltype(types.timestamp)>(rt, value.getProperty(rt, "timestamp"), jsInvoker),
      bridging::fromJs<decltype(types.originalPayload)>(rt, value.getProperty(rt, "originalPayload"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String callIdToJs(jsi::Runtime &rt, decltype(types.callId) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String callerNameToJs(jsi::Runtime &rt, decltype(types.callerName) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String callerPhoneToJs(jsi::Runtime &rt, decltype(types.callerPhone) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String callerAvatarToJs(jsi::Runtime &rt, decltype(types.callerAvatar) value) {
    return bridging::toJs(rt, value);
  }

  static bool hasVideoToJs(jsi::Runtime &rt, decltype(types.hasVideo) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String endReasonToJs(jsi::Runtime &rt, decltype(types.endReason) value) {
    return bridging::toJs(rt, value);
  }

  static double timestampToJs(jsi::Runtime &rt, decltype(types.timestamp) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Object originalPayloadToJs(jsi::Runtime &rt, decltype(types.originalPayload) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "callId", bridging::toJs(rt, value.callId, jsInvoker));
    result.setProperty(rt, "callerName", bridging::toJs(rt, value.callerName, jsInvoker));
    result.setProperty(rt, "callerPhone", bridging::toJs(rt, value.callerPhone, jsInvoker));
    if (value.callerAvatar) {
      result.setProperty(rt, "callerAvatar", bridging::toJs(rt, value.callerAvatar.value(), jsInvoker));
    }
    if (value.hasVideo) {
      result.setProperty(rt, "hasVideo", bridging::toJs(rt, value.hasVideo.value(), jsInvoker));
    }
    if (value.endReason) {
      result.setProperty(rt, "endReason", bridging::toJs(rt, value.endReason.value(), jsInvoker));
    }
    if (value.timestamp) {
      result.setProperty(rt, "timestamp", bridging::toJs(rt, value.timestamp.value(), jsInvoker));
    }
    if (value.originalPayload) {
      result.setProperty(rt, "originalPayload", bridging::toJs(rt, value.originalPayload.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - NativeCallxCallxConfig

template <typename P0, typename P1>
struct NativeCallxCallxConfig {
  P0 fieldMapping;
  P1 triggers;
  bool operator==(const NativeCallxCallxConfig &other) const {
    return fieldMapping == other.fieldMapping && triggers == other.triggers;
  }
};

template <typename T>
struct NativeCallxCallxConfigBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.fieldMapping)>(rt, value.getProperty(rt, "fieldMapping"), jsInvoker),
      bridging::fromJs<decltype(types.triggers)>(rt, value.getProperty(rt, "triggers"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::Object fieldMappingToJs(jsi::Runtime &rt, decltype(types.fieldMapping) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Object triggersToJs(jsi::Runtime &rt, decltype(types.triggers) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    if (value.fieldMapping) {
      result.setProperty(rt, "fieldMapping", bridging::toJs(rt, value.fieldMapping.value(), jsInvoker));
    }
    if (value.triggers) {
      result.setProperty(rt, "triggers", bridging::toJs(rt, value.triggers.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - NativeCallxFieldMappingConfig

template <typename P0, typename P1>
struct NativeCallxFieldMappingConfig {
  P0 path;
  P1 fallback;
  bool operator==(const NativeCallxFieldMappingConfig &other) const {
    return path == other.path && fallback == other.fallback;
  }
};

template <typename T>
struct NativeCallxFieldMappingConfigBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.path)>(rt, value.getProperty(rt, "path"), jsInvoker),
      bridging::fromJs<decltype(types.fallback)>(rt, value.getProperty(rt, "fallback"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String pathToJs(jsi::Runtime &rt, decltype(types.path) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String fallbackToJs(jsi::Runtime &rt, decltype(types.fallback) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "path", bridging::toJs(rt, value.path, jsInvoker));
    if (value.fallback) {
      result.setProperty(rt, "fallback", bridging::toJs(rt, value.fallback.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - NativeCallxTriggerConfigEntry

template <typename P0, typename P1>
struct NativeCallxTriggerConfigEntry {
  P0 field;
  P1 value;
  bool operator==(const NativeCallxTriggerConfigEntry &other) const {
    return field == other.field && value == other.value;
  }
};

template <typename T>
struct NativeCallxTriggerConfigEntryBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.field)>(rt, value.getProperty(rt, "field"), jsInvoker),
      bridging::fromJs<decltype(types.value)>(rt, value.getProperty(rt, "value"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String fieldToJs(jsi::Runtime &rt, decltype(types.field) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String valueToJs(jsi::Runtime &rt, decltype(types.value) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "field", bridging::toJs(rt, value.field, jsInvoker));
    result.setProperty(rt, "value", bridging::toJs(rt, value.value, jsInvoker));
    return result;
  }
};

class JSI_EXPORT NativeCallxCxxSpecJSI : public TurboModule {
protected:
  NativeCallxCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Value initialize(jsi::Runtime &rt, jsi::Object config) = 0;
  virtual jsi::Value showIncomingCall(jsi::Runtime &rt, jsi::Object callData) = 0;
  virtual jsi::Value endCall(jsi::Runtime &rt, jsi::String callId) = 0;
  virtual jsi::Value answerCall(jsi::Runtime &rt, jsi::String callId) = 0;
  virtual jsi::Value declineCall(jsi::Runtime &rt, jsi::String callId) = 0;
  virtual jsi::Value getFCMToken(jsi::Runtime &rt) = 0;
  virtual jsi::Value getVoIPToken(jsi::Runtime &rt) = 0;
  virtual jsi::Value setFieldMapping(jsi::Runtime &rt, jsi::String field, jsi::String path, std::optional<jsi::String> fallback) = 0;
  virtual jsi::Value setTrigger(jsi::Runtime &rt, jsi::String trigger, jsi::String field, jsi::String value) = 0;
  virtual jsi::Value getCurrentCall(jsi::Runtime &rt) = 0;
  virtual jsi::Value isCallActive(jsi::Runtime &rt) = 0;
  virtual jsi::Value handleFcmMessage(jsi::Runtime &rt, jsi::Object data) = 0;
  virtual jsi::Value hideFromLockScreen(jsi::Runtime &rt) = 0;
  virtual jsi::Value moveAppToBackground(jsi::Runtime &rt) = 0;
  virtual jsi::Value getConfiguration(jsi::Runtime &rt) = 0;

};

template <typename T>
class JSI_EXPORT NativeCallxCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "Callx";

protected:
  NativeCallxCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeCallxCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativeCallxCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeCallxCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    jsi::Value initialize(jsi::Runtime &rt, jsi::Object config) override {
      static_assert(
          bridging::getParameterCount(&T::initialize) == 2,
          "Expected initialize(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::initialize, jsInvoker_, instance_, std::move(config));
    }
    jsi::Value showIncomingCall(jsi::Runtime &rt, jsi::Object callData) override {
      static_assert(
          bridging::getParameterCount(&T::showIncomingCall) == 2,
          "Expected showIncomingCall(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::showIncomingCall, jsInvoker_, instance_, std::move(callData));
    }
    jsi::Value endCall(jsi::Runtime &rt, jsi::String callId) override {
      static_assert(
          bridging::getParameterCount(&T::endCall) == 2,
          "Expected endCall(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::endCall, jsInvoker_, instance_, std::move(callId));
    }
    jsi::Value answerCall(jsi::Runtime &rt, jsi::String callId) override {
      static_assert(
          bridging::getParameterCount(&T::answerCall) == 2,
          "Expected answerCall(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::answerCall, jsInvoker_, instance_, std::move(callId));
    }
    jsi::Value declineCall(jsi::Runtime &rt, jsi::String callId) override {
      static_assert(
          bridging::getParameterCount(&T::declineCall) == 2,
          "Expected declineCall(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::declineCall, jsInvoker_, instance_, std::move(callId));
    }
    jsi::Value getFCMToken(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getFCMToken) == 1,
          "Expected getFCMToken(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getFCMToken, jsInvoker_, instance_);
    }
    jsi::Value getVoIPToken(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getVoIPToken) == 1,
          "Expected getVoIPToken(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getVoIPToken, jsInvoker_, instance_);
    }
    jsi::Value setFieldMapping(jsi::Runtime &rt, jsi::String field, jsi::String path, std::optional<jsi::String> fallback) override {
      static_assert(
          bridging::getParameterCount(&T::setFieldMapping) == 4,
          "Expected setFieldMapping(...) to have 4 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::setFieldMapping, jsInvoker_, instance_, std::move(field), std::move(path), std::move(fallback));
    }
    jsi::Value setTrigger(jsi::Runtime &rt, jsi::String trigger, jsi::String field, jsi::String value) override {
      static_assert(
          bridging::getParameterCount(&T::setTrigger) == 4,
          "Expected setTrigger(...) to have 4 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::setTrigger, jsInvoker_, instance_, std::move(trigger), std::move(field), std::move(value));
    }
    jsi::Value getCurrentCall(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getCurrentCall) == 1,
          "Expected getCurrentCall(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getCurrentCall, jsInvoker_, instance_);
    }
    jsi::Value isCallActive(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::isCallActive) == 1,
          "Expected isCallActive(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::isCallActive, jsInvoker_, instance_);
    }
    jsi::Value handleFcmMessage(jsi::Runtime &rt, jsi::Object data) override {
      static_assert(
          bridging::getParameterCount(&T::handleFcmMessage) == 2,
          "Expected handleFcmMessage(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::handleFcmMessage, jsInvoker_, instance_, std::move(data));
    }
    jsi::Value hideFromLockScreen(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::hideFromLockScreen) == 1,
          "Expected hideFromLockScreen(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::hideFromLockScreen, jsInvoker_, instance_);
    }
    jsi::Value moveAppToBackground(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::moveAppToBackground) == 1,
          "Expected moveAppToBackground(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::moveAppToBackground, jsInvoker_, instance_);
    }
    jsi::Value getConfiguration(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConfiguration) == 1,
          "Expected getConfiguration(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getConfiguration, jsInvoker_, instance_);
    }

  private:
    friend class NativeCallxCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};

} // namespace facebook::react
